{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Prajwal/Desktop/crypto-dashboard-dec/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"C:/Users/Prajwal/Desktop/crypto-dashboard-dec/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"C:/Users/Prajwal/Desktop/crypto-dashboard-dec/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Prajwal/Desktop/crypto-dashboard-dec/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Prajwal/Desktop/crypto-dashboard-dec/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/*!\n * Chart.js v4.1.0\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nimport { Color } from '@kurkle/color';\n\n/**\n * @namespace Chart.helpers\n */ /**\n    * An empty function that can be used, for example, for optional callback.\n    */\nfunction noop() {\n  /* noop */}\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nvar uid = function () {\n  var id = 0;\n  return function () {\n    return id++;\n  };\n}();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  var type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value) {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\nvar toPercentage = function toPercentage(value, dimension) {\n  return typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\n};\nvar toDimension = function toDimension(value, dimension) {\n  return typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n};\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  var i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nfunction _elementsEqual(a0, a1) {\n  var i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nfunction clone(source) {\n  if (isArray(source)) {\n    return source.map(clone);\n  }\n  if (isObject(source)) {\n    var target = Object.create(null);\n    var keys = Object.keys(source);\n    var klen = keys.length;\n    var k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  var tval = target[key];\n  var sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\nfunction merge(target, source, options) {\n  var sources = isArray(source) ? source : [source];\n  var ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  var merger = options.merger || _merger;\n  var current;\n  for (var i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n    var keys = Object.keys(current);\n    for (var k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge(target, source, {\n    merger: _mergerIf\n  });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  var tval = target[key];\n  var sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n/**\n * @private\n */\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n// resolveObjectKey resolver cache\nvar keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': function _(v) {\n    return v;\n  },\n  // default resolvers\n  x: function x(o) {\n    return o.x;\n  },\n  y: function y(o) {\n    return o.y;\n  }\n};\n/**\n * @private\n */\nfunction _splitKey(key) {\n  var parts = key.split('.');\n  var keys = [];\n  var tmp = '';\n  var _iterator = _createForOfIteratorHelper(parts),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var part = _step.value;\n      tmp += part;\n      if (tmp.endsWith('\\\\')) {\n        tmp = tmp.slice(0, -1) + '.';\n      } else {\n        keys.push(tmp);\n        tmp = '';\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return keys;\n}\nfunction _getKeyResolver(key) {\n  var keys = _splitKey(key);\n  return function (obj) {\n    var _iterator2 = _createForOfIteratorHelper(keys),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var k = _step2.value;\n        if (k === '') {\n          break;\n        }\n        obj = obj && obj[k];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return obj;\n  };\n}\nfunction resolveObjectKey(obj, key) {\n  var resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n/**\n * @private\n */\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nvar defined = function defined(value) {\n  return typeof value !== 'undefined';\n};\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nvar setsEqual = function setsEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  var _iterator3 = _createForOfIteratorHelper(a),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      if (!b.has(item)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return true;\n};\n/**\n * @param e - The event\n * @private\n */\nfunction _isClickEvent(e) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\nvar PI = Math.PI;\nvar TAU = 2 * PI;\nvar PITAU = TAU + PI;\nvar INFINITY = Number.POSITIVE_INFINITY;\nvar RAD_PER_DEG = PI / 180;\nvar HALF_PI = PI / 2;\nvar QUARTER_PI = PI / 4;\nvar TWO_THIRDS_PI = PI * 2 / 3;\nvar log10 = Math.log10;\nvar sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nfunction niceNum(range) {\n  var roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  var niceRange = Math.pow(10, Math.floor(log10(range)));\n  var fraction = range / niceRange;\n  var niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nfunction _factorize(value) {\n  var result = [];\n  var sqrt = Math.sqrt(value);\n  var i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort(function (a, b) {\n    return a - b;\n  }).pop();\n  return result;\n}\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n  var rounded = Math.round(x);\n  return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */\nfunction _setMinAndMaxByKey(array, target, property) {\n  var i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  var e = 1;\n  var p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  var distanceFromXCenter = anglePoint.x - centrePoint.x;\n  var distanceFromYCenter = anglePoint.y - centrePoint.y;\n  var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < -0.5 * PI) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n  return {\n    angle: angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  var a = _normalizeAngle(angle);\n  var s = _normalizeAngle(start);\n  var e = _normalizeAngle(end);\n  var angleToStart = _normalizeAngle(s - a);\n  var angleToEnd = _normalizeAngle(e - a);\n  var startToAngle = _normalizeAngle(a - s);\n  var endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nfunction _isBetween(value, start, end) {\n  var epsilon = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-6;\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || function (index) {\n    return table[index] < value;\n  };\n  var hi = table.length - 1;\n  var lo = 0;\n  var mid;\n  while (hi - lo > 1) {\n    mid = lo + hi >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {\n    lo: lo,\n    hi: hi\n  };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nvar _lookupByKey = function _lookupByKey(table, key, value, last) {\n  return _lookup(table, value, last ? function (index) {\n    var ti = table[index][key];\n    return ti < value || ti === value && table[index + 1][key] === value;\n  } : function (index) {\n    return table[index][key] < value;\n  });\n};\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nvar _rlookupByKey = function _rlookupByKey(table, key, value) {\n  return _lookup(table, value, function (index) {\n    return table[index][key] >= value;\n  });\n};\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nfunction _filterBetween(values, min, max) {\n  var start = 0;\n  var end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach(function (key) {\n    var method = '_onData' + _capitalize(key);\n    var base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value: function value() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var res = base.apply(this, args);\n        array._chartjs.listeners.forEach(function (object) {\n          if (typeof object[method] === 'function') {\n            object[method].apply(object, args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  var stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  var listeners = stub.listeners;\n  var index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach(function (key) {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\n/**\n * @param items\n */\nfunction _arrayUnique(items) {\n  var set = new Set();\n  var i, ilen;\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n  if (set.size === ilen) {\n    return items;\n  }\n  return Array.from(set);\n}\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/\nvar requestAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return function (callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nfunction throttled(fn, thisArg) {\n  var argsToUse = [];\n  var ticking = false;\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, function () {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */\nfunction debounce(fn, delay) {\n  var timeout;\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nvar _toLeftRightCenter = function _toLeftRightCenter(align) {\n  return align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n};\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nvar _alignStartEnd = function _alignStartEnd(align, start, end) {\n  return align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n};\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nvar _textX = function _textX(align, left, right, rtl) {\n  var check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  var pointCount = points.length;\n  var start = 0;\n  var count = pointCount;\n  if (meta._sorted) {\n    var iScale = meta.iScale,\n      _parsed = meta._parsed;\n    var axis = iScale.axis;\n    var _iScale$getUserBounds = iScale.getUserBounds(),\n      min = _iScale$getUserBounds.min,\n      max = _iScale$getUserBounds.max,\n      minDefined = _iScale$getUserBounds.minDefined,\n      maxDefined = _iScale$getUserBounds.maxDefined;\n    if (minDefined) {\n      start = _limitValue(Math.min(\n      // @ts-expect-error Need to type _parsed\n      _lookupByKey(_parsed, iScale.axis, min).lo,\n      // @ts-expect-error Need to fix types on _lookupByKey\n      animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n      // @ts-expect-error Need to type _parsed\n      _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n      // @ts-expect-error Need to fix types on _lookupByKey\n      animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {\n    start: start,\n    count: count\n  };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nfunction _scaleRangesChanged(meta) {\n  var xScale = meta.xScale,\n    yScale = meta.yScale,\n    _scaleRanges = meta._scaleRanges;\n  var newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  var changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\nvar atEdge = function atEdge(t) {\n  return t === 0 || t === 1;\n};\nvar elasticIn = function elasticIn(t, s, p) {\n  return -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\n};\nvar elasticOut = function elasticOut(t, s, p) {\n  return Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n};\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nvar effects = {\n  linear: function linear(t) {\n    return t;\n  },\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  easeOutQuad: function easeOutQuad(t) {\n    return -t * (t - 2);\n  },\n  easeInOutQuad: function easeInOutQuad(t) {\n    return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);\n  },\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  easeOutCubic: function easeOutCubic(t) {\n    return (t -= 1) * t * t + 1;\n  },\n  easeInOutCubic: function easeInOutCubic(t) {\n    return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2);\n  },\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  easeOutQuart: function easeOutQuart(t) {\n    return -((t -= 1) * t * t * t - 1);\n  },\n  easeInOutQuart: function easeInOutQuart(t) {\n    return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2);\n  },\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  easeOutQuint: function easeOutQuint(t) {\n    return (t -= 1) * t * t * t * t + 1;\n  },\n  easeInOutQuint: function easeInOutQuint(t) {\n    return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2);\n  },\n  easeInSine: function easeInSine(t) {\n    return -Math.cos(t * HALF_PI) + 1;\n  },\n  easeOutSine: function easeOutSine(t) {\n    return Math.sin(t * HALF_PI);\n  },\n  easeInOutSine: function easeInOutSine(t) {\n    return -0.5 * (Math.cos(PI * t) - 1);\n  },\n  easeInExpo: function easeInExpo(t) {\n    return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));\n  },\n  easeOutExpo: function easeOutExpo(t) {\n    return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n  },\n  easeInOutExpo: function easeInOutExpo(t) {\n    return atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2);\n  },\n  easeInCirc: function easeInCirc(t) {\n    return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1);\n  },\n  easeOutCirc: function easeOutCirc(t) {\n    return Math.sqrt(1 - (t -= 1) * t);\n  },\n  easeInOutCirc: function easeInOutCirc(t) {\n    return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n  },\n  easeInElastic: function easeInElastic(t) {\n    return atEdge(t) ? t : elasticIn(t, 0.075, 0.3);\n  },\n  easeOutElastic: function easeOutElastic(t) {\n    return atEdge(t) ? t : elasticOut(t, 0.075, 0.3);\n  },\n  easeInOutElastic: function easeInOutElastic(t) {\n    var s = 0.1125;\n    var p = 0.45;\n    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack: function easeInBack(t) {\n    var s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack: function easeOutBack(t) {\n    var s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack: function easeInOutBack(t) {\n    var s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  },\n  easeInBounce: function easeInBounce(t) {\n    return 1 - effects.easeOutBounce(1 - t);\n  },\n  easeOutBounce: function easeOutBounce(t) {\n    var m = 7.5625;\n    var d = 2.75;\n    if (t < 1 / d) {\n      return m * t * t;\n    }\n    if (t < 2 / d) {\n      return m * (t -= 1.5 / d) * t + 0.75;\n    }\n    if (t < 2.5 / d) {\n      return m * (t -= 2.25 / d) * t + 0.9375;\n    }\n    return m * (t -= 2.625 / d) * t + 0.984375;\n  },\n  easeInOutBounce: function easeInOutBounce(t) {\n    return t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n  }\n};\nfunction isPatternOrGradient(value) {\n  if (value && typeof value === 'object') {\n    var type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n  return false;\n}\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\nvar numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nvar colors = ['color', 'borderColor', 'backgroundColor'];\nfunction applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined\n  });\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: function _scriptable(name) {\n      return name !== 'onProgress' && name !== 'onComplete' && name !== 'fn';\n    }\n  });\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    }\n  });\n  defaults.describe('animations', {\n    _fallback: 'animation'\n  });\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0\n        }\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: function fn(v) {\n            return v | 0;\n          }\n        }\n      }\n    }\n  });\n}\nfunction applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\nvar intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  var cacheKey = locale + JSON.stringify(options);\n  var formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\nvar formatters = {\n  values: function values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n  numeric: function numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    var locale = this.chart.options.locale;\n    var notation;\n    var delta = tickValue;\n    if (ticks.length > 1) {\n      var maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    var logDelta = log10(Math.abs(delta));\n    var numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    var options = {\n      notation: notation,\n      minimumFractionDigits: numDecimal,\n      maximumFractionDigits: numDecimal\n    };\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n  logarithmic: function logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    var remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  var delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {\n  formatters: formatters\n};\nfunction applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n    bounds: 'ticks',\n    grace: 0,\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: function tickWidth(_ctx, options) {\n        return options.lineWidth;\n      },\n      tickColor: function tickColor(_ctx, options) {\n        return options.color;\n      },\n      offset: false\n    },\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n    title: {\n      display: false,\n      text: '',\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2\n    }\n  });\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: function _scriptable(name) {\n      return !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser';\n    },\n    _indexable: function _indexable(name) {\n      return name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash';\n    }\n  });\n  defaults.describe('scales', {\n    _fallback: 'scale'\n  });\n  defaults.describe('scale.ticks', {\n    _scriptable: function _scriptable(name) {\n      return name !== 'backdropPadding' && name !== 'callback';\n    },\n    _indexable: function _indexable(name) {\n      return name !== 'backdropPadding';\n    }\n  });\n}\nvar overrides = Object.create(null);\nvar descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  var keys = key.split('.');\n  for (var i = 0, n = keys.length; i < n; ++i) {\n    var k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\nfunction _set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, ''), scope);\n}\nvar Defaults = /*#__PURE__*/function () {\n  function Defaults(_descriptors, _appliers) {\n    _classCallCheck(this, Defaults);\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = function (context) {\n      return context.chart.platform.getDevicePixelRatio();\n    };\n    this.elements = {};\n    this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = function (ctx, options) {\n      return getHoverColor(options.backgroundColor);\n    };\n    this.hoverBorderColor = function (ctx, options) {\n      return getHoverColor(options.borderColor);\n    };\n    this.hoverColor = function (ctx, options) {\n      return getHoverColor(options.color);\n    };\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n  _createClass(Defaults, [{\n    key: \"set\",\n    value: function set(scope, values) {\n      return _set(this, scope, values);\n    }\n  }, {\n    key: \"get\",\n    value: function get(scope) {\n      return getScope$1(this, scope);\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(scope, values) {\n      return _set(descriptors, scope, values);\n    }\n  }, {\n    key: \"override\",\n    value: function override(scope, values) {\n      return _set(overrides, scope, values);\n    }\n  }, {\n    key: \"route\",\n    value: function route(scope, name, targetScope, targetName) {\n      var _Object$definePropert;\n      var scopeObject = getScope$1(this, scope);\n      var targetScopeObject = getScope$1(this, targetScope);\n      var privateName = '_' + name;\n      Object.defineProperties(scopeObject, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, privateName, {\n        value: scopeObject[name],\n        writable: true\n      }), _defineProperty(_Object$definePropert, name, {\n        enumerable: true,\n        get: function get() {\n          var local = this[privateName];\n          var target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set: function set(value) {\n          this[privateName] = value;\n        }\n      }), _Object$definePropert));\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(appliers) {\n      var _this = this;\n      appliers.forEach(function (apply) {\n        return apply(_this);\n      });\n    }\n  }]);\n  return Defaults;\n}();\nvar defaults = /* #__PURE__ */new Defaults({\n  _scriptable: function _scriptable(name) {\n    return !name.startsWith('on');\n  },\n  _indexable: function _indexable(name) {\n    return name !== 'events';\n  },\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n  var textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  var data = cache.data = cache.data || {};\n  var gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  var longest = 0;\n  var ilen = arrayOfThings.length;\n  var i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  var gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n  var devicePixelRatio = chart.currentDevicePixelRatio;\n  var halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n  var type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n  var style = options.pointStyle;\n  var rotation = options.rotation;\n  var radius = options.radius;\n  var rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    var midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction renderText(ctx, text, x, y, font) {\n  var opts = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var lines = isArray(text) ? text : [text];\n  var stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  var i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n  ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    var metrics = ctx.measureText(line);\n    var left = x - metrics.actualBoundingBoxLeft;\n    var right = x + metrics.actualBoundingBoxRight;\n    var top = y - metrics.actualBoundingBoxAscent;\n    var bottom = y + metrics.actualBoundingBoxDescent;\n    var yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction drawBackdrop(ctx, opts) {\n  var oldColor = ctx.fillStyle;\n  ctx.fillStyle = opts.color;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\nfunction addRoundedRectPath(ctx, rect) {\n  var x = rect.x,\n    y = rect.y,\n    w = rect.w,\n    h = rect.h,\n    radius = rect.radius;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\nvar LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nvar FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n    * Converts the given line height `value` in pixels for a specific font `size`.\n    * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n    * @param size - The font size (in pixels) used to resolve relative `value`.\n    * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n    * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n    * @since 2.7.0\n    */\nfunction toLineHeight(value, size) {\n  var matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n  }\n  return size * value;\n}\nvar numberOrZero = function numberOrZero(v) {\n  return +v || 0;\n};\nfunction _readValueToProps(value, props) {\n  var ret = {};\n  var objProps = isObject(props);\n  var keys = objProps ? Object.keys(props) : props;\n  var read = isObject(value) ? objProps ? function (prop) {\n    return valueOrDefault(value[prop], value[props[prop]]);\n  } : function (prop) {\n    return value[prop];\n  } : function () {\n    return value;\n  };\n  var _iterator4 = _createForOfIteratorHelper(keys),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var prop = _step4.value;\n      ret[prop] = numberOrZero(read(prop));\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nfunction toTRBL(value) {\n  return _readValueToProps(value, {\n    top: 'y',\n    right: 'x',\n    bottom: 'y',\n    left: 'x'\n  });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nfunction toPadding(value) {\n  var obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  var size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  var style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n  var font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size: size,\n    style: style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nfunction resolve(inputs, context, index, info) {\n  var cacheable = true;\n  var i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nfunction _addGrace(minmax, grace, beginAtZero) {\n  var min = minmax.min,\n    max = minmax.max;\n  var change = toDimension(grace, (max - min) / 2);\n  var keepZero = function keepZero(value, add) {\n    return beginAtZero && value === 0 ? 0 : value + add;\n  };\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\nfunction _createResolver(scopes) {\n  var _cache;\n  var prefixes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [''];\n  var rootScopes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : scopes;\n  var fallback = arguments.length > 3 ? arguments[3] : undefined;\n  var getTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {\n    return scopes[0];\n  };\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n  var cache = (_cache = {}, _defineProperty(_cache, Symbol.toStringTag, 'Object'), _defineProperty(_cache, \"_cacheable\", true), _defineProperty(_cache, \"_scopes\", scopes), _defineProperty(_cache, \"_rootScopes\", rootScopes), _defineProperty(_cache, \"_fallback\", fallback), _defineProperty(_cache, \"_getTarget\", getTarget), _defineProperty(_cache, \"override\", function override(scope) {\n    return _createResolver([scope].concat(_toConsumableArray(scopes)), prefixes, rootScopes, fallback);\n  }), _cache);\n  return new Proxy(cache, {\n    deleteProperty: function deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n    get: function get(target, prop) {\n      return _cached(target, prop, function () {\n        return _resolveWithPrefixes(prop, prefixes, scopes, target);\n      });\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    getPrototypeOf: function getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    has: function has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    ownKeys: function ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    set: function set(target, prop, value) {\n      var storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value;\n      delete target._keys;\n      return true;\n    }\n  });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  var cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: function setContext(ctx) {\n      return _attachContext(proxy, ctx, subProxy, descriptorDefaults);\n    },\n    override: function override(scope) {\n      return _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults);\n    }\n  };\n  return new Proxy(cache, {\n    deleteProperty: function deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n    get: function get(target, prop, receiver) {\n      return _cached(target, prop, function () {\n        return _resolveWithContext(target, prop, receiver);\n      });\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n        enumerable: true,\n        configurable: true\n      } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    getPrototypeOf: function getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    has: function has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    ownKeys: function ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    set: function set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n  });\n}\nfunction _descriptors(proxy) {\n  var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    scriptable: true,\n    indexable: true\n  };\n  var _proxy$_scriptable = proxy._scriptable,\n    _scriptable = _proxy$_scriptable === void 0 ? defaults.scriptable : _proxy$_scriptable,\n    _proxy$_indexable = proxy._indexable,\n    _indexable = _proxy$_indexable === void 0 ? defaults.indexable : _proxy$_indexable,\n    _proxy$_allKeys = proxy._allKeys,\n    _allKeys = _proxy$_allKeys === void 0 ? defaults.allKeys : _proxy$_allKeys;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : function () {\n      return _scriptable;\n    },\n    isIndexable: isFunction(_indexable) ? _indexable : function () {\n      return _indexable;\n    }\n  };\n}\nvar readKey = function readKey(prefix, name) {\n  return prefix ? prefix + _capitalize(name) : name;\n};\nvar needsSubResolver = function needsSubResolver(prop, value) {\n  return isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\n};\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n  var value = resolve();\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  var _proxy = target._proxy,\n    _context = target._context,\n    _subProxy = target._subProxy,\n    descriptors = target._descriptors;\n  var value = _proxy[prop];\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n  var _proxy = target._proxy,\n    _context = target._context,\n    _subProxy = target._subProxy,\n    _stack = target._stack;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  value = value(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  var _proxy = target._proxy,\n    _context = target._context,\n    _subProxy = target._subProxy,\n    descriptors = target._descriptors;\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    var arr = value;\n    var scopes = _proxy._scopes.filter(function (s) {\n      return s !== arr;\n    });\n    value = [];\n    var _iterator5 = _createForOfIteratorHelper(arr),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var item = _step5.value;\n        var resolver = createSubResolver(scopes, _proxy, prop, item);\n        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nvar getScope = function getScope(key, parent) {\n  return key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n};\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n  var _iterator6 = _createForOfIteratorHelper(parentScopes),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var parent = _step6.value;\n      var scope = getScope(key, parent);\n      if (scope) {\n        set.add(scope);\n        var fallback = resolveFallback(scope._fallback, key, value);\n        if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n          return fallback;\n        }\n      } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n        return null;\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  var rootScopes = resolver._rootScopes;\n  var fallback = resolveFallback(resolver._fallback, prop, value);\n  var allScopes = [].concat(_toConsumableArray(parentScopes), _toConsumableArray(rootScopes));\n  var set = new Set();\n  set.add(value);\n  var key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback, function () {\n    return subGetTarget(resolver, prop, value);\n  });\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  var parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  var target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n  return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  var value;\n  var _iterator7 = _createForOfIteratorHelper(prefixes),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var prefix = _step7.value;\n      value = _resolve(readKey(prefix, prop), scopes);\n      if (defined(value)) {\n        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\nfunction _resolve(key, scopes) {\n  var _iterator8 = _createForOfIteratorHelper(scopes),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var scope = _step8.value;\n      if (!scope) {\n        continue;\n      }\n      var value = scope[key];\n      if (defined(value)) {\n        return value;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  var keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  var set = new Set();\n  var _iterator9 = _createForOfIteratorHelper(scopes),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var scope = _step9.value;\n      var _iterator10 = _createForOfIteratorHelper(Object.keys(scope).filter(function (k) {\n          return !k.startsWith('_');\n        })),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var key = _step10.value;\n          set.add(key);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n  var iScale = meta.iScale;\n  var _this$_parsing$key = this._parsing.key,\n    key = _this$_parsing$key === void 0 ? 'r' : _this$_parsing$key;\n  var parsed = new Array(count);\n  var i, ilen, index, item;\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\nvar EPSILON = Number.EPSILON || 1e-14;\nvar getPoint = function getPoint(points, i) {\n  return i < points.length && !points[i].skip && points[i];\n};\nvar getValueAxis = function getValueAxis(indexAxis) {\n  return indexAxis === 'x' ? 'y' : 'x';\n};\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n  // This function must also respect \"skipped\" points\n  var previous = firstPoint.skip ? middlePoint : firstPoint;\n  var current = middlePoint;\n  var next = afterPoint.skip ? middlePoint : afterPoint;\n  var d01 = distanceBetweenPoints(current, previous);\n  var d12 = distanceBetweenPoints(next, current);\n  var s01 = d01 / (d01 + d12);\n  var s12 = d12 / (d01 + d12);\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  var fa = t * s01; // scaling factor for triangle Ta\n  var fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points, deltaK, mK) {\n  var pointsLen = points.length;\n  var alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  var pointAfter = getPoint(points, 0);\n  for (var i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK) {\n  var indexAxis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'x';\n  var valueAxis = getValueAxis(indexAxis);\n  var pointsLen = points.length;\n  var delta, pointBefore, pointCurrent;\n  var pointAfter = getPoint(points, 0);\n  for (var i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    var iPixel = pointCurrent[indexAxis];\n    var vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[\"cp1\".concat(indexAxis)] = iPixel - delta;\n      pointCurrent[\"cp1\".concat(valueAxis)] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[\"cp2\".concat(indexAxis)] = iPixel + delta;\n      pointCurrent[\"cp2\".concat(valueAxis)] = vPixel + delta * mK[i];\n    }\n  }\n}\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nfunction splineCurveMonotone(points) {\n  var indexAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n  var valueAxis = getValueAxis(indexAxis);\n  var pointsLen = points.length;\n  var deltaK = Array(pointsLen).fill(0);\n  var mK = Array(pointsLen);\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  var i, pointBefore, pointCurrent;\n  var pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      var slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  var i, ilen, point, inArea, inAreaPrev;\n  var inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n/**\n * @private\n */\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  var i, ilen, point, controlPoints;\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter(function (pt) {\n      return !pt.skip;\n    });\n  }\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    var prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */ /**\n    * @private\n    */\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * @private\n */\nfunction _getParentNode(domNode) {\n  var parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n  return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  var valueInPixels;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nvar getComputedStyle = function getComputedStyle(element) {\n  return element.ownerDocument.defaultView.getComputedStyle(element, null);\n};\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nvar positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n  var result = {};\n  suffix = suffix ? '-' + suffix : '';\n  for (var i = 0; i < 4; i++) {\n    var pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nvar useOffsetPos = function useOffsetPos(x, y, target) {\n  return (x > 0 || y > 0) && (!target || !target.shadowRoot);\n};\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(e, canvas) {\n  var touches = e.touches;\n  var source = touches && touches.length ? touches[0] : e;\n  var offsetX = source.offsetX,\n    offsetY = source.offsetY;\n  var box = false;\n  var x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    var rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {\n    x: x,\n    y: y,\n    box: box\n  };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\nfunction getRelativePosition(event, chart) {\n  if ('native' in event) {\n    return event;\n  }\n  var canvas = chart.canvas,\n    currentDevicePixelRatio = chart.currentDevicePixelRatio;\n  var style = getComputedStyle(canvas);\n  var borderBox = style.boxSizing === 'border-box';\n  var paddings = getPositionedStyle(style, 'padding');\n  var borders = getPositionedStyle(style, 'border', 'width');\n  var _getCanvasPosition = getCanvasPosition(event, canvas),\n    x = _getCanvasPosition.x,\n    y = _getCanvasPosition.y,\n    box = _getCanvasPosition.box;\n  var xOffset = paddings.left + (box && borders.left);\n  var yOffset = paddings.top + (box && borders.top);\n  var width = chart.width,\n    height = chart.height;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  var maxWidth, maxHeight;\n  if (width === undefined || height === undefined) {\n    var container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      var rect = container.getBoundingClientRect(); // this is the border box of the container\n      var containerStyle = getComputedStyle(container);\n      var containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      var containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width: width,\n    height: height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nvar round1 = function round1(v) {\n  return Math.round(v * 10) / 10;\n};\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  var style = getComputedStyle(canvas);\n  var margins = getPositionedStyle(style, 'margin');\n  var maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  var maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  var containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  var width = containerSize.width,\n    height = containerSize.height;\n  if (style.boxSizing === 'content-box') {\n    var borders = getPositionedStyle(style, 'border', 'width');\n    var paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n  var maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n  return {\n    width: width,\n    height: height\n  };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  var pixelRatio = forceRatio || 1;\n  var deviceHeight = Math.floor(chart.height * pixelRatio);\n  var deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  var canvas = chart.canvas;\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n    canvas.style.height = \"\".concat(chart.height, \"px\");\n    canvas.style.width = \"\".concat(chart.width, \"px\");\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nvar supportsEventListenerOptions = function () {\n  var passiveSupported = false;\n  try {\n    var options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\nfunction readUsedSize(element, property) {\n  var value = getStyle(element, property);\n  var matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\n/**\n * @private\n */\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n/**\n * @private\n */\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n  };\n}\n/**\n * @private\n */\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  var cp1 = {\n    x: p1.cp2x,\n    y: p1.cp2y\n  };\n  var cp2 = {\n    x: p2.cp1x,\n    y: p2.cp1y\n  };\n  var a = _pointInLine(p1, cp1, t);\n  var b = _pointInLine(cp1, cp2, t);\n  var c = _pointInLine(cp2, p2, t);\n  var d = _pointInLine(a, b, t);\n  var e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\nvar getRightToLeftAdapter = function getRightToLeftAdapter(rectX, width) {\n  return {\n    x: function x(_x) {\n      return rectX + rectX + width - _x;\n    },\n    setWidth: function setWidth(w) {\n      width = w;\n    },\n    textAlign: function textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus: function xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr: function leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    }\n  };\n};\nvar getLeftToRightAdapter = function getLeftToRightAdapter() {\n  return {\n    x: function x(_x2) {\n      return _x2;\n    },\n    setWidth: function setWidth(w) {},\n    textAlign: function textAlign(align) {\n      return align;\n    },\n    xPlus: function xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr: function leftForLtr(x, _itemWidth) {\n      return x;\n    }\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  var style, original;\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: function compare(a, b) {\n      return a - b;\n    },\n    normalize: function normalize(x) {\n      return x;\n    }\n  };\n}\nfunction normalizeSegment(_ref) {\n  var start = _ref.start,\n    end = _ref.end,\n    count = _ref.count,\n    loop = _ref.loop,\n    style = _ref.style;\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style: style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  var property = bounds.property,\n    startBound = bounds.start,\n    endBound = bounds.end;\n  var _propertyFn = propertyFn(property),\n    between = _propertyFn.between,\n    normalize = _propertyFn.normalize;\n  var count = points.length;\n  var start = segment.start,\n    end = segment.end,\n    loop = segment.loop;\n  var i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {\n    start: start,\n    end: end,\n    loop: loop,\n    style: segment.style\n  };\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  var property = bounds.property,\n    startBound = bounds.start,\n    endBound = bounds.end;\n  var count = points.length;\n  var _propertyFn2 = propertyFn(property),\n    compare = _propertyFn2.compare,\n    between = _propertyFn2.between,\n    normalize = _propertyFn2.normalize;\n  var _getSegment = getSegment(segment, points, bounds),\n    start = _getSegment.start,\n    end = _getSegment.end,\n    loop = _getSegment.loop,\n    style = _getSegment.style;\n  var result = [];\n  var inside = false;\n  var subStart = null;\n  var value, point, prevValue;\n  var startIsBefore = function startIsBefore() {\n    return between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  };\n  var endIsBefore = function endIsBefore() {\n    return compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  };\n  var shouldStart = function shouldStart() {\n    return inside || startIsBefore();\n  };\n  var shouldStop = function shouldStop() {\n    return !inside || endIsBefore();\n  };\n  for (var i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({\n        start: subStart,\n        end: i,\n        loop: loop,\n        count: count,\n        style: style\n      }));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({\n      start: subStart,\n      end: end,\n      loop: loop,\n      count: count,\n      style: style\n    }));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  var result = [];\n  var segments = line.segments;\n  for (var i = 0; i < segments.length; i++) {\n    var sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push.apply(result, _toConsumableArray(sub));\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  var start = 0;\n  var end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {\n    start: start,\n    end: end\n  };\n}\nfunction solidSegments(points, start, max, loop) {\n  var count = points.length;\n  var result = [];\n  var last = start;\n  var prev = points[start];\n  var end;\n  for (end = start + 1; end <= max; ++end) {\n    var cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({\n          start: start % count,\n          end: (end - 1) % count,\n          loop: loop\n        });\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({\n      start: start % count,\n      end: last % count,\n      loop: loop\n    });\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  var points = line.points;\n  var spanGaps = line.options.spanGaps;\n  var count = points.length;\n  if (!count) {\n    return [];\n  }\n  var loop = !!line._loop;\n  var _findStartAndEnd = findStartAndEnd(points, count, loop, spanGaps),\n    start = _findStartAndEnd.start,\n    end = _findStartAndEnd.end;\n  if (spanGaps === true) {\n    return splitByStyles(line, [{\n      start: start,\n      end: end,\n      loop: loop\n    }], points, segmentOptions);\n  }\n  var max = end < start ? end + count : end;\n  var completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  var chartContext = line._chart.getContext();\n  var baseStyle = readStyle(line.options);\n  var datasetIndex = line._datasetIndex,\n    spanGaps = line.options.spanGaps;\n  var count = points.length;\n  var result = [];\n  var prevStyle = baseStyle;\n  var start = segments[0].start;\n  var i = start;\n  function addStyle(s, e, l, st) {\n    var dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({\n        start: s % count,\n        end: e % count,\n        loop: l,\n        style: st\n      });\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  var _iterator11 = _createForOfIteratorHelper(segments),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var segment = _step11.value;\n      start = spanGaps ? start : segment.start;\n      var prev = points[start % count];\n      var style = void 0;\n      for (i = start + 1; i <= segment.end; i++) {\n        var pt = points[i % count];\n        style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n          type: 'segment',\n          p0: prev,\n          p1: pt,\n          p0DataIndex: (i - 1) % count,\n          p1DataIndex: i % count,\n          datasetIndex: datasetIndex\n        })));\n        if (styleChanged(style, prevStyle)) {\n          addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n        prev = pt;\n        prevStyle = style;\n      }\n      if (start < i - 1) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\nexport { unclipArea as $, _rlookupByKey as A, _lookupByKey as B, _isPointInArea as C, getAngleFromPoint as D, toPadding as E, each as F, getMaximumSize as G, HALF_PI as H, _getParentNode as I, readUsedSize as J, supportsEventListenerOptions as K, throttled as L, _isDomSupported as M, _factorize as N, finiteOrDefault as O, PI as P, callback as Q, _addGrace as R, _limitValue as S, TAU as T, toDegrees as U, _measureText as V, _int16Range as W, _alignPixel as X, clipArea as Y, renderText as Z, _arrayUnique as _, resolve as a, fontString as a$, toFont as a0, _toLeftRightCenter as a1, _alignStartEnd as a2, overrides as a3, merge as a4, _capitalize as a5, descriptors as a6, isFunction as a7, _attachContext as a8, _createResolver as a9, overrideTextDirection as aA, _textX as aB, restoreTextDirection as aC, drawPointLegend as aD, distanceBetweenPoints as aE, noop as aF, _setMinAndMaxByKey as aG, niceNum as aH, almostWhole as aI, almostEquals as aJ, _decimalPlaces as aK, Ticks as aL, log10 as aM, _longestText as aN, _filterBetween as aO, _lookup as aP, isPatternOrGradient as aQ, getHoverColor as aR, clone as aS, _merger as aT, _mergerIf as aU, _deprecated as aV, _splitKey as aW, toFontString as aX, splineCurve as aY, splineCurveMonotone as aZ, getStyle as a_, _descriptors as aa, mergeIf as ab, uid as ac, debounce as ad, retinaScale as ae, clearCanvas as af, setsEqual as ag, _elementsEqual as ah, _isClickEvent as ai, _isBetween as aj, _readValueToProps as ak, _updateBezierControlPoints as al, _computeSegments as am, _boundSegments as an, _steppedInterpolation as ao, _bezierInterpolation as ap, _pointInLine as aq, _steppedLineTo as ar, _bezierCurveTo as as, drawPoint as at, addRoundedRectPath as au, toTRBL as av, toTRBLCorners as aw, _boundSegment as ax, _normalizeAngle as ay, getRtlAdapter as az, isArray as b, toLineHeight as b0, PITAU as b1, INFINITY as b2, RAD_PER_DEG as b3, QUARTER_PI as b4, TWO_THIRDS_PI as b5, _angleDiff as b6, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, defined as h, isObject as i, createContext as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, getRelativePosition as z };","map":{"version":3,"mappings":"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","names":["noop","uid","id","isNullOrUndef","value","isArray","Array","type","Object","prototype","toString","call","slice","isObject","isNumberFinite","Number","isFinite","finiteOrDefault","defaultValue","valueOrDefault","toPercentage","dimension","endsWith","parseFloat","toDimension","callback","fn","args","thisArg","apply","each","loopable","reverse","i","len","keys","length","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","index","clone","source","map","target","create","klen","k","isValidKey","key","indexOf","_merger","options","tval","sval","merge","sources","merger","current","mergeIf","_mergerIf","hasOwnProperty","_deprecated","scope","previous","undefined","console","warn","keyResolvers","v","x","o","y","_splitKey","parts","split","tmp","_step","part","push","_iterator","_getKeyResolver","obj","_step2","_iterator2","resolveObjectKey","resolver","_capitalize","str","charAt","toUpperCase","defined","isFunction","setsEqual","a","b","size","_step3","item","has","_iterator3","_isClickEvent","e","PI","Math","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","epsilon","abs","niceNum","range","roundedRange","round","niceRange","pow","floor","fraction","niceFraction","_factorize","result","sqrt","sort","pop","isNumber","n","isNaN","almostWhole","rounded","_setMinAndMaxByKey","array","property","min","max","toRadians","degrees","toDegrees","radians","_decimalPlaces","isFiniteNumber","p","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","start","end","sameAngleIsFullCircle","s","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_int16Range","_isBetween","_lookup","table","cmp","hi","lo","mid","_lookupByKey","last","ti","_rlookupByKey","_filterBetween","values","arrayEvents","listenArrayEvents","listener","_chartjs","listeners","defineProperty","configurable","enumerable","forEach","method","base","res","object","unlistenArrayEvents","stub","splice","_arrayUnique","items","set","Set","add","from","fontString","pixelSize","fontStyle","fontFamily","requestAnimFrame","window","requestAnimationFrame","throttled","argsToUse","ticking","debounce","delay","timeout","clearTimeout","setTimeout","_toLeftRightCenter","align","_alignStartEnd","_textX","left","right","rtl","check","_getStartAndCountOfVisiblePoints","meta","points","animationsDisabled","pointCount","count","_sorted","iScale","_parsed","axis","getUserBounds","minDefined","maxDefined","getPixelForValue","_scaleRangesChanged","xScale","yScale","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","changed","assign","atEdge","t","elasticIn","sin","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","m","d","easeInOutBounce","isPatternOrGradient","color","Color","getHoverColor","saturate","darken","hexString","numbers","colors","applyAnimationsDefaults","defaults","duration","easing","loop","to","describe","_fallback","_indexable","_scriptable","name","properties","active","animation","resize","show","animations","visible","hide","applyLayoutsDefaults","autoPadding","padding","top","bottom","intlCache","Map","getNumberFormat","locale","cacheKey","JSON","stringify","formatter","get","Intl","NumberFormat","formatNumber","num","format","formatters","numeric","tickValue","ticks","chart","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","remain","significand","includes","applyScaleDefaults","display","offset","beginAtZero","bounds","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","_ctx","tickColor","border","dash","dashOffset","width","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","Ticks","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","route","startsWith","overrides","descriptors","getScope","node","root","Defaults","constructor","_descriptors","_appliers","_classCallCheck","backgroundColor","borderColor","datasets","devicePixelRatio","context","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","weight","hover","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","_createClass","override","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","local","appliers","_this","toFontString","_measureText","data","gc","longest","string","textWidth","measureText","_longestText","arrayOfThings","cache","garbageCollect","save","j","jlen","thing","nestedThing","restore","gcLen","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","resetTransform","clearRect","height","drawPoint","drawPointLegend","w","xOffset","yOffset","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","radius","rad","translate","rotate","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","_isPointInArea","point","area","margin","clipArea","clip","unclipArea","_steppedLineTo","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","renderText","opts","lines","strokeWidth","strokeColor","line","setRenderOpts","backdrop","drawBackdrop","strokeStyle","strokeText","maxWidth","fillText","decorateText","translation","fillStyle","textAlign","textBaseline","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","decorationWidth","oldColor","fillRect","addRoundedRectPath","h","topLeft","bottomLeft","bottomRight","topRight","LINE_HEIGHT","FONT_STYLE","toLineHeight","matches","match","numberOrZero","_readValueToProps","props","ret","objProps","read","prop","_step4","_iterator4","toTRBL","toTRBLCorners","toPadding","toFont","fallback","parseInt","resolve","inputs","info","cacheable","_addGrace","minmax","change","keepZero","createContext","parentContext","_createResolver","scopes","prefixes","rootScopes","getTarget","_resolve","Symbol","toStringTag","Proxy","deleteProperty","_keys","_cached","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","_scopes","getPrototypeOf","getKeysFromAllScopes","ownKeys","storage","_storage","_attachContext","proxy","subProxy","descriptorDefaults","_cacheable","_proxy","_context","_subProxy","_stack","setContext","receiver","_resolveWithContext","allKeys","scriptable","indexable","_proxy$_indexable","_proxy$_allKeys","_allKeys","isScriptable","isIndexable","readKey","prefix","needsSubResolver","_resolveScriptable","_resolveArray","Error","join","delete","createSubResolver","arr","filter","_step5","_iterator5","resolveFallback","parent","addScopes","parentScopes","parentFallback","_step6","_iterator6","_rootScopes","allScopes","addScopesFromKey","subGetTarget","_getTarget","_step7","_iterator7","_step8","_iterator8","resolveKeysFromAllScopes","_step9","_step10","_iterator10","_iterator9","_parseObjectDataRadialScale","_parsing","parsed","r","parse","EPSILON","getPoint","skip","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","next","d01","d12","s01","s12","fa","fb","monotoneAdjust","deltaK","mK","pointsLen","alphaK","betaK","tauK","squaredMagnitude","pointCurrent","pointAfter","monotoneCompute","valueAxis","pointBefore","iPixel","vPixel","splineCurveMonotone","slopeDelta","capControlPoint","pt","capBezierPoints","inArea","inAreaPrev","inAreaNext","_updateBezierControlPoints","controlPoints","spanGaps","cubicInterpolationMode","prev","tension","_isDomSupported","document","_getParentNode","domNode","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","ownerDocument","defaultView","getStyle","el","getPropertyValue","positions","getPositionedStyle","styles","suffix","pos","useOffsetPos","shadowRoot","getCanvasPosition","touches","offsetX","offsetY","box","getBoundingClientRect","clientX","clientY","getRelativePosition","event","borderBox","boxSizing","paddings","borders","getContainerSize","maxHeight","container","clientWidth","clientHeight","containerStyle","containerBorder","containerPadding","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","containerSize","maintainHeight","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","_pointInLine","p1","p2","_steppedInterpolation","_bezierInterpolation","cp1","cp2","c","getRightToLeftAdapter","rectX","setWidth","xPlus","leftForLtr","itemWidth","getLeftToRightAdapter","_itemWidth","getRtlAdapter","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","normalizeSegment","getSegment","segment","startBound","endBound","_boundSegment","inside","subStart","prevValue","startIsBefore","endIsBefore","shouldStart","shouldStop","_boundSegments","segments","sub","findStartAndEnd","solidSegments","cur","stop","_computeSegments","segmentOptions","_loop","splitByStyles","completeLoop","_fullLoop","doSplitByStyles","chartContext","_chart","baseStyle","readStyle","_datasetIndex","prevStyle","addStyle","l","st","dir","_step11","p0","p0DataIndex","p1DataIndex","styleChanged","_iterator11","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle"],"sources":["C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.core.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.math.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.collection.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.extras.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.easing.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.color.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\core\\core.animations.defaults.js","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\core\\core.layouts.defaults.js","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.intl.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\core\\core.ticks.js","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\core\\core.scale.defaults.js","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\core\\core.defaults.js","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.canvas.js","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.options.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.config.js","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.curve.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.dom.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.interpolation.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.rtl.ts","C:\\Users\\Prajwal\\Desktop\\crypto-dashboard-dec\\node_modules\\chart.js\\src\\helpers\\helpers.segment.js"],"sourcesContent":["/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || typeof value === 'undefined';\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): AnyObject {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>();\n  let i: number, ilen: number;\n\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n\n  if (set.size === ilen) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0); // toFixed has a max of 20 decimal places\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","import {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `canvas` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } canvas.Chart\n * @typedef { import('../../types/index.js').Point } Point\n */\n\n/**\n * @namespace Chart.helpers.canvas\n */\n\n/**\n * Converts the given font object into a CSS font string.\n * @param {object} font - A font object.\n * @return {string|null} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\n/**\n * @private\n */\nexport function _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param {canvas.Chart} chart - The chart instance.\n * @param {number} pixel - A pixel value.\n * @param {number} width - The width of the element.\n * @returns {number} The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n * @param {HTMLCanvasElement} canvas\n * @param {CanvasRenderingContext2D} [ctx]\n */\nexport function clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport function drawPoint(ctx, options, x, y) {\n  drawPointLegend(ctx, options, x, y, null);\n}\n\nexport function drawPointLegend(ctx, options, x, y, w) {\n  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n  default:\n    if (w) {\n      ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n    } else {\n      ctx.arc(x, y, radius, 0, TAU);\n    }\n    ctx.closePath();\n    break;\n  case 'triangle':\n    width = w ? w / 2 : radius;\n    ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n    ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      width = w ? w / 2 : size;\n      ctx.rect(x - width, y - size, 2 * width, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n    /* falls through */\n  case 'rectRot':\n    xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n    ctx.moveTo(x - xOffsetW, y - yOffset);\n    ctx.lineTo(x + yOffsetW, y - xOffset);\n    ctx.lineTo(x + xOffsetW, y + yOffset);\n    ctx.lineTo(x - yOffsetW, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n    /* falls through */\n  case 'cross':\n    xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n    ctx.moveTo(x - xOffsetW, y - yOffset);\n    ctx.lineTo(x + xOffsetW, y + yOffset);\n    ctx.moveTo(x + yOffsetW, y - xOffset);\n    ctx.lineTo(x - yOffsetW, y + xOffset);\n    break;\n  case 'star':\n    xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n    ctx.moveTo(x - xOffsetW, y - yOffset);\n    ctx.lineTo(x + xOffsetW, y + yOffset);\n    ctx.moveTo(x + yOffsetW, y - xOffset);\n    ctx.lineTo(x - yOffsetW, y + xOffset);\n    rad += QUARTER_PI;\n    xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n    ctx.moveTo(x - xOffsetW, y - yOffset);\n    ctx.lineTo(x + xOffsetW, y + yOffset);\n    ctx.moveTo(x + yOffsetW, y - xOffset);\n    ctx.lineTo(x - yOffsetW, y + xOffset);\n    break;\n  case 'line':\n    xOffset = w ? w / 2 : Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n    break;\n  case false:\n    ctx.closePath();\n    break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param {Point} point - The point to test\n * @param {object} area - The rectangle\n * @param {number} [margin] - allowed margin\n * @returns {boolean}\n * @private\n */\nexport function _isPointInArea(point, area, margin) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += font.lineHeight;\n  }\n\n  ctx.restore();\n}\n\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx, opts) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nexport function addRoundedRectPath(ctx, rect) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {Point, toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec} from '../../types/index.js';\nimport type {TRBL, TRBLCorners} from '../../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\nexport interface CanvasFontSpec extends FontSpec {\n  string: string;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","import {defined, isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param {object[]} scopes - The option scopes to look for values, in resolution order\n * @param {string[]} [prefixes] - The prefixes for values, in resolution order.\n * @param {object[]} [rootScopes] - The root option scopes\n * @param {string|boolean} [fallback] - Parent scopes fallback\n * @param {function} [getTarget] - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  });\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param {object} proxy - The Proxy returned by `_createResolver`\n * @param {object} context - Context object for scriptable/indexable options\n * @param {object} [subProxy] - The proxy provided for scriptable options\n * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults] - Defaults for descriptors\n * @private\n */\nexport function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  });\n}\n\n/**\n * @private\n */\nexport function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(target, prop, receiver) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    // @ts-ignore\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  value = value(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key, parent) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop, value));\n}\n\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (defined(value)) {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(meta, data, start, count) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array(count);\n  let i, ilen, index, item;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../../types/index.js';\n\nexport interface SplinePoint {\n  x: number;\n  y: number;\n  skip?: boolean;\n\n  // Both Bezier and monotone interpolations have these fields\n  // but they are added in different spots\n  cp1x?: number;\n  cp1y?: number;\n  cp2x?: number;\n  cp2y?: number;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import type {ChartArea, Scale} from '../../types/index.js';\nimport type Chart from '../core/core.controller.js';\nimport type {ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {Point} from '../../types/geometric.js';\nimport type {SplinePoint} from './helpers.curve.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}